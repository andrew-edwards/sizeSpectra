% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fitting.R
\name{binData}
\alias{binData}
\title{Construct bins either double in size or are of equal width, and encompass
the data}
\usage{
binData(
  x = NULL,
  counts = NULL,
  binWidth = NULL,
  binBreaks = NULL,
  startInteger = TRUE
)
}
\arguments{
\item{x}{vector of individual values (e.g. body masses). Only \code{x} or
\code{counts} can be specified.}

\item{counts}{dataframe (or array) with first column being an x value
(e.g. body mass), and second column being the counts of the
number of individuals for that value. Only \code{x} (the vector) or \code{counts} can
be specified.}

\item{binWidth}{type of bins to use:
\itemize{
\item \code{"2k"} will result in \code{binBreaks} that:
\itemize{
\item with \code{startInteger=TRUE} are powers of 2, i.e. ..., 0.25, 0.5, 1, 2, 4, 8, 16,....
\item with \code{startInteger=FALSE} are bins that double in size and  start with
\code{min(x)}; not yet implemented, since have to think about what the width of
the first bin should be.
}
\item numeric value (call it \code{a}) will result in binBreaks are separated by \code{a} and span the
data, that:
\itemize{
\item with \code{startInteger=TRUE} start from \code{z = floor(min(x))} and are then
\verb{z, z+a, z+2a, z+3a, ....}   (if \code{z = 0} then power-law cannot be fit
so then need to use \code{startInteger=FALSE})
\item with \code{startInteger=FALSE} start from \code{z = min(x)} and are then
\verb{z, z+a, z+2a, z+3a, ....}
}
\item only \code{binWidth} or \code{binBreaks} can be specified.
}}

\item{binBreaks}{pre-defined bin breaks as a vector. Only \code{binWidth}
or \code{binBreaks} can be specified.}

\item{startInteger}{TRUE or FALSE, whether to start the bin breaks at an integer
power of 2 (for method \code{"2k"}) or an integer. See \code{binWidth} above.
\code{startInteger} is ignored if \code{binBreaks} is specified.}
}
\value{
list containing:
\itemize{
\item indiv: dataframe with a row for each \code{x} value, with columns:
\itemize{
\item \code{x}: original \code{x} values
\item \code{binMid}, \code{binMin}, \code{binMax}, \code{binWidth}: midpoint, minimum,
maximum, and width, respectively, of the bin within
which the \code{x} value falls.  If indiv has \verb{>=10^6} rows then it isn't saved.
If \code{counts} was specified then an equivalent \code{x}
vector is created and is column \code{x} (i.e. \code{x} values are repeated). May
not be the most efficient way, but it easiest to program.
}
\item binVals: dataframe with a row for each new bin and columns:
\itemize{
\item \code{binMid}, \code{binMin}, \code{binMax}, \code{binWidth}: midpoint, minimum,
maximum, and width, respectively, of the bin
\item \code{binCount}: total number of individuals in that bin
\item \code{binCountNorm}: normalised bin count, \code{binCount / binWidth}
\item \code{binSum}: sum of individual values in that bin (appropriate if \code{x}
represents biomass, but not length)
\item \code{binSumNorm}: \code{binSum / binWidth}
\item \code{log10....} - \code{log10()} of some of the above quantities
}
}
}
\description{
Construct bins that start from \code{floor(min(x))} or \code{min(x)} and either double
in size or are of equal width, and encompass the data. More generalised
version of \code{log2bins()}.
}
\author{
Andrew Edwards
}
